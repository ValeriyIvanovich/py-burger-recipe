from abc import ABC, abstractmethodclass Validator(ABC):    @abstractmethod    def validate(self) -> None:        pass    @abstractmethod    def __set_name__(self, owner: str, name: str) -> None:        pass    def __get__(self, instance: str, owner: str) -> None:        return getattr(instance, self.protected_name, None)    def __set__(self, instance: str, value: int) -> None:        setattr(instance, self.protected_name, value)class Number:    def __init__(            self, min_value: int, max_value: int, protected_name: int = None    ) -> None:        self.min_value = min_value        self.max_value = max_value        self.protected_name = protected_name    def validate(self, value: int) -> None:        return (isinstance(value, int)                and self.min_value <= value <= self.max_value                )    def __get__(self, instance: str, owner: int) -> str:        if instance is None:            return self        return getattr(instance, self.protected_name)    def __set__(self, instance: str, value: int) -> str:        if not self.validate(value):            raise ValueError(                f'Invalid value "{value}". Value should be an integer '                f"between {self.min_value} and {self.max_value}."            )        setattr(instance, self.protected_name, value)class OneOf:    def __init__(self, options: str) -> None:        self.options = options        self.protected_name = None    def __set_name__(self, owner: int, name: str) -> str:        self.protected_name = f"_{name}"    def __get__(self, instance: int, owner: str) -> None:        if instance is None:            return self        return getattr(instance, self.protected_name)    def __set__(self, instance: str, value: int) -> str:        if value not in self.options:            raise (                ValueError(f'Invalid value "{value}". '                           f'Options are: {", ".join(self.options)}.')            )        if self.min_value is not None and value < self.min_value:            raise (                ValueError(f'Value "{value}" is less than '                           f'the minimum value "{self.min_value}".')            )        if self.max_value is not None and value > self.max_value:            raise (                ValueError(f'Value "{value}" is greater '                           f'than the maximum value "{self.max_value}".')            )        setattr(instance, self.protected_name, value)    def validate(self) -> None:        return (            isinstance(self.value, str)            and self.value in self.options            and (self.min_value is None or self.value >= self.min_value)            and (self.max_value is None or self.value <= self.max_value)        )class BurgerRecipe:    cheese = Number(min_value=1, max_value=3, protected_name="_cheese")    tomatoes = Number(        min_value=0, max_value=5, protected_name="_tomatoes"    )    cutlets = Number(min_value=1, max_value=2, protected_name="_cutlets")    eggs = Number(min_value=0, max_value=2, protected_name="_eggs")    buns = Number(min_value=2, max_value=3, protected_name="_buns")    sauce = OneOf(["ketchup", "mayo", "burger"])    def __init__(            self, buns: int, cheese: int, tomatoes: int,            cutlets: int, eggs: int, sauce: str    ) -> None:        if (            not isinstance(buns, int)            or not isinstance(cheese, int)            or not isinstance(tomatoes, int)            or not isinstance(cutlets, int)            or not isinstance(eggs, int)        ):            raise TypeError("Quantity should be integer.")        if buns not in (2, 3):            raise ValueError(                "Quantity should not be less than 2 and greater than 3."            )        if cheese not in (0, 1, 2):            raise ValueError(                "Quantity should not be less than 0 and greater than 2."            )        if tomatoes not in (0, 1, 2, 3):            raise ValueError(                "Quantity should not be less than 0 and greater than 3."            )        if cutlets not in (1, 2, 3):            raise ValueError(                "Quantity should not be less than 1 and greater than 3."            )        if eggs not in (0, 1, 2):            raise ValueError(                "Quantity should not be less than 0 and greater than 2."            )        if sauce not in ("ketchup", "mayo", "burger"):            raise ValueError(                "Expected mustard to be one of "                "('ketchup', 'mayo', 'burger')."            )        self._buns = int(buns)        self._cheese = int(cheese)        self._tomatoes = int(tomatoes)        self._cutlets = int(cutlets)        self._eggs = int(eggs)        self._sauce = str(sauce)